<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Communication Learning Game</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }
        body {
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            padding: 20px;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .game-info {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            margin-bottom: 20px;
            gap: 10px;
        }
        .game-info-item {
            flex: 1;
            min-width: 150px;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .info-label {
            font-size: 14px;
            margin-bottom: 5px;
            color: #6c757d;
        }
        .info-value {
            font-size: 18px;
            font-weight: bold;
            color: #4a6fa5;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            min-height: 400px; /* Set minimum height to prevent layout shift */
        }
        .card-container {
            perspective: 1000px;
            aspect-ratio: 1 / 1;
            cursor: pointer;
        }
        .card {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.5s;
        }
        .card.flipped {
            transform: rotateY(180deg);
        }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            font-size: 14px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        .card-front {
            background-color: #4a6fa5;
            color: white;
        }
        .card-back {
            background-color: #e9ecef;
            transform: rotateY(180deg);
            font-weight: bold;
        }
        .feedback-btns {
            display: none;
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            justify-content: center;
            gap: 10px;
            z-index: 10;
        }
        .correct-btn, .incorrect-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
        }
        .correct-btn {
            background-color: #28a745;
            color: white;
        }
        .incorrect-btn {
            background-color: #dc3545;
            color: white;
        }
        .button-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        .game-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: transform 0.1s, background-color 0.2s;
            min-width: 140px;
            justify-content: center;
        }
        .game-btn:hover {
            transform: translateY(-2px);
        }
        .game-btn:active {
            transform: translateY(0);
        }
        .reset-btn {
            background-color: #4a6fa5;
            color: white;
        }
        .shuffle-btn {
            background-color: #6c757d;
            color: white;
        }
        .upload-btn {
            background-color: #17a2b8;
            color: white;
        }
        .empty-slot {
            background-color: rgba(74, 111, 165, 0.1);
            border: 2px dashed rgba(74, 111, 165, 0.3);
            border-radius: 8px;
        }
        .card-container.animate-out {
            animation: fadeOut 0.5s forwards;
        }
        .card-container.animate-in {
            animation: fadeIn 0.5s forwards;
        }
        .shuffle-animation {
            animation: shuffle 0.8s ease-in-out;
        }
        @keyframes shuffle {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(-5deg) scale(0.95); }
            75% { transform: rotate(5deg) scale(0.95); }
            100% { transform: rotate(0deg) scale(1); }
        }
        @keyframes fadeOut {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.8); }
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        .completion-message {
            text-align: center;
            background-color: #d4edda;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            color: #155724;
            display: none;
            animation: fadeIn 0.5s;
        }
        .completion-message h2 {
            margin-top: 0;
        }
        .completion-message.show {
            display: block;
        }
        .completion-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
        }
        .completion-stat {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #28a745;
        }
        .stat-label {
            font-size: 14px;
            color: #155724;
        }
        .btn-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
        /* File upload styles */
        .file-upload {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }
        .file-upload.show {
            display: flex;
        }
        .upload-container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
            position: relative;
        }
        .upload-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .upload-header h2 {
            margin: 0;
            font-size: 20px;
        }
        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #6c757d;
        }
        .file-input-container {
            border: 2px dashed #4a6fa5;
            padding: 20px;
            text-align: center;
            border-radius: 8px;
            margin-bottom: 20px;
            cursor: pointer;
        }
        .file-input-container:hover {
            background-color: rgba(74, 111, 165, 0.05);
        }
        .file-input {
            display: none;
        }
        .or-divider {
            display: flex;
            align-items: center;
            margin: 20px 0;
            color: #6c757d;
        }
        .or-divider::before, .or-divider::after {
            content: "";
            flex: 1;
            border-bottom: 1px solid #dee2e6;
            margin: 0 10px;
        }
        .paste-area {
            width: 100%;
            height: 150px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 20px;
            resize: none;
            font-size: 14px;
        }
        .upload-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        .upload-help {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        .upload-help h3 {
            font-size: 16px;
            margin-top: 0;
            margin-bottom: 8px;
        }
        .upload-help code {
            background-color: #e9ecef;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }
        .format-example {
            font-family: monospace;
            color: #495057;
        }
        .success-message {
            color: #28a745;
            margin-bottom: 10px;
            display: none;
        }
        .error-message {
            color: #dc3545;
            margin-bottom: 10px;
            display: none;
        }
        @media (max-width: 768px) {
            .grid-container {
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: repeat(4, 1fr);
            }
            .game-info-item {
                min-width: 120px;
            }
            .button-container {
                flex-direction: column;
                align-items: center;
            }
            .game-btn {
                width: 100%;
                justify-content: center;
            }
        }
        @media (max-width: 480px) {
            .grid-container {
                grid-template-columns: repeat(1, 1fr);
                grid-template-rows: repeat(8, 1fr);
                min-height: 800px;
            }
            .card-face {
                font-size: 12px;
                padding: 12px;
            }
            .feedback-btns {
                flex-direction: column;
                align-items: center;
            }
            .game-info {
                flex-direction: column;
            }
            .game-info-item {
                width: 100%;
            }
            .completion-stats {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Visual Communication Learning Game</h1>
            <p>Each card shows a definition. Click to reveal the term and mark if you got it right or wrong.</p>
            <p>Cards you know will be replaced with new ones. In the final stage, mastered cards will disappear!</p>
        </div>

        <div class="game-info">
            <div class="game-info-item">
                <div class="info-label">Learned</div>
                <div class="info-value" id="score">0</div>
            </div>
            <div class="game-info-item">
                <div class="info-label">Cards Remaining</div>
                <div class="info-value" id="remaining">27</div>
            </div>
            <div class="game-info-item">
                <div class="info-label">Time</div>
                <div class="info-value" id="timer">00:00</div>
            </div>
        </div>

        <div class="completion-message" id="completion-message">
            <h2>Congratulations!</h2>
            <p>You've mastered all visual communication terms!</p>
            
            <div class="completion-stats">
                <div class="completion-stat">
                    <div class="stat-value" id="final-score">0</div>
                    <div class="stat-label">Terms Mastered</div>
                </div>
                <div class="completion-stat">
                    <div class="stat-value" id="final-time">00:00</div>
                    <div class="stat-label">Completion Time</div>
                </div>
            </div>
        </div>

        <div class="grid-container" id="grid">
            <!-- Cards will be generated here by JavaScript -->
        </div>

        <div class="button-container">
            <button id="upload-btn" class="game-btn upload-btn">
                <svg class="btn-icon" viewBox="0 0 24 24">
                    <path d="M19.35,10.04C18.67,6.59,15.64,4,12,4C9.11,4,6.6,5.64,5.35,8.04C2.34,8.36,0,10.91,0,14c0,3.31,2.69,6,6,6h13c2.76,0,5-2.24,5-5C24,12.36,21.95,10.22,19.35,10.04z M14,13v4h-4v-4H7l5-5l5,5H14z"></path>
                </svg>
                Upload Terms
            </button>
            <button id="shuffle-btn" class="game-btn shuffle-btn">
                <svg class="btn-icon" viewBox="0 0 24 24">
                    <path d="M21.5,9L21.5,9c0,0.3-0.1,0.5-0.3,0.7l-2.3,2.3l2.3,2.3c0.2,0.2,0.3,0.4,0.3,0.7l0,0c0,0.6-0.4,1-1,1H16c-0.6,0-1-0.4-1-1v-6c0-0.6,0.4-1,1-1h4.5C21.1,8,21.5,8.4,21.5,9z M8,8H2.5C1.7,8,1,8.7,1,9.5v5C1,15.3,1.7,16,2.5,16H8c2.2,0,4,1.8,4,4h2c0-3.3-2.7-6-6-6H3v-4h5c3.3,0,6-2.7,6-6h-2C12,6.2,10.2,8,8,8z M19,13h-3v-2h3L19,13z M13,16h-2c0,2.2-1.8,4-4,4H2.5C1.7,20,1,20.7,1,21.5v0C1,22.3,1.7,23,2.5,23H7c4.4,0,8-3.6,8-8v-1C14.3,14,13.8,14.5,13,16z M23,2.5L23,2.5c0-0.8-0.7-1.5-1.5-1.5H17c-4.4,0-8,3.6-8,8h2c0-3.3,2.7-6,6-6h4v4h-3.5c-0.8,0-1.5,0.7-1.5,1.5v0c0,0.8,0.7,1.5,1.5,1.5H22c0.6,0,1-0.4,1-1V2.5z"></path>
                </svg>
                Shuffle Cards
            </button>
            <button id="reset-btn" class="game-btn reset-btn">
                <svg class="btn-icon" viewBox="0 0 24 24">
                    <path d="M12,21c-4.97,0-9-4.03-9-9s4.03-9,9-9c2.39,0,4.68,0.94,6.36,2.63l-2.89,2.89C14.54,7.59,13.29,7,12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5h2c0,3.87-3.13,7-7,7L12,21z M19,10V7h-3l3.29-3.29L21.5,5l-3.29,3.29L19,10z"></path>
                </svg>
                Reset Game
            </button>
        </div>
    </div>

    <!-- File Upload Modal -->
    <div class="file-upload" id="file-upload">
        <div class="upload-container">
            <div class="upload-header">
                <h2>Upload Custom Terms</h2>
                <button class="close-btn" id="close-upload">Ã—</button>
            </div>
            
            <div class="upload-help">
                <h3>File Format</h3>
                <p>Upload a CSV or TXT file with term-definition pairs. Each line should be in the format:</p>
                <p class="format-example">Term,Definition</p>
                <p>For example:</p>
                <p class="format-example">Metaphor,A figure of speech that makes a comparison between two things.</p>
            </div>
            
            <div class="file-input-container" id="file-drop-area">
                <p>Drag &amp; drop your file here or click to browse</p>
                <input type="file" id="file-input" class="file-input" accept=".csv,.txt">
            </div>
            
            <div class="or-divider">OR</div>
            
            <p>Paste your terms directly (one per line in Term,Definition format):</p>
            <textarea id="paste-area" class="paste-area" placeholder="Metaphor,A figure of speech that makes a comparison between two things."></textarea>
            
            <div id="success-message" class="success-message">Terms imported successfully!</div>
            <div id="error-message" class="error-message">Error importing terms. Please check the format.</div>
            
            <div class="upload-footer">
                <button id="cancel-upload" class="game-btn shuffle-btn">Cancel</button>
                <button id="import-terms" class="game-btn reset-btn">Import Terms</button>
            </div>
        </div>
    </div>

    <script>
        // Default Visual Communication Terms
        const defaultFlashcards = [
            { term: "Semiotics", definition: "The study of signs and symbols and how meaning is constructed." },
            { term: "Signifier", definition: "The form a sign takes (e.g., word, image, sound)." },
            { term: "Signified", definition: "The concept or meaning the signifier represents." },
            { term: "Denotation", definition: "The literal, surface-level meaning of an image." },
            { term: "Connotation", definition: "The cultural or emotional associations attached to an image or sign." },
            { term: "Myth", definition: "Deeply embedded cultural narratives or ideologies conveyed by images." },
            { term: "Code", definition: "A system of signs understood within a culture (e.g., color codes, fashion codes)." },
            { term: "Anchorage", definition: "Text or captions that fix the meaning of an image." },
            { term: "Gestalt Principles", definition: "Rules of perception that explain how we visually organize information (e.g., proximity, similarity, closure, continuity)." },
            { term: "Figure-Ground", definition: "The relationship between an object (figure) and its background (ground)." },
            { term: "Closure", definition: "The tendency to perceive a complete image even when parts are missing." },
            { term: "Proximity", definition: "Elements close together are perceived as a group." },
            { term: "Similarity", definition: "Elements that look alike are seen as related." },
            { term: "Continuity", definition: "Our eyes follow lines or paths, even across breaks." },
            { term: "Visual Hierarchy", definition: "The arrangement of elements to show order of importance." },
            { term: "Framing", definition: "The way visual information is presented to guide interpretation." },
            { term: "Composition", definition: "The arrangement of visual elements in an image or design." },
            { term: "Perspective", definition: "The technique used to represent three-dimensional space on a two-dimensional surface." },
            { term: "Cropping", definition: "Selecting part of an image to focus attention or change meaning." },
            { term: "Juxtaposition", definition: "Placing images side-by-side to create contrast or comparison." },
            { term: "Typography", definition: "The art and technique of arranging type for visual communication." },
            { term: "Iconography", definition: "The study of symbols and imagery within a particular context." },
            { term: "Color Theory", definition: "The study of how colors interact and the psychological effects of color." },
            { term: "Visual Metaphor", definition: "A visual symbol that represents another concept or idea." },
            { term: "Representation", definition: "The depiction of subjects in visual media and the implications of how they're shown." },
            { term: "Index", definition: "A sign that shows evidence of what is being represented (e.g., smoke as an index of fire)." },
            { term: "Icon", definition: "A sign that physically resembles what it stands for (e.g., a portrait, a restroom symbol)." },
            { term: "Symbol", definition: "A sign with an arbitrary connection to its meaning, learned through culture (e.g., a national flag)." },
            { term: "Interpellation", definition: "The process by which viewers are positioned to identify with particular ideologies within a visual message." },
            { term: "Polysemy", definition: "The capacity for a visual sign to have multiple meanings depending on the viewer or context." },
            { term: "Symmetry", definition: "The balanced distribution of elements, often associated with harmony and stability." },
            { term: "Asymmetry", definition: "A dynamic, unbalanced composition often used to create tension or visual interest." },
            { term: "Visual Clarity", definition: "The ease with which a viewer can perceive and interpret an image's components." },
            { term: "Salience", definition: "The quality of an element standing out in a visual field, often due to contrast, size, or color." },
            { term: "Equilibrium", definition: "The visual balance of elements in a composition that creates a sense of completeness." }
        ];

        // Current set of flashcards (use default initially)
        let allFlashcards = [...defaultFlashcards];

        // DOM elements
        const gridContainer = document.getElementById('grid');
        const scoreElement = document.getElementById('score');
        const remainingElement = document.getElementById('remaining');
        const timerElement = document.getElementById('timer');
        const resetButton = document.getElementById('reset-btn');
        const shuffleButton = document.getElementById('shuffle-btn');
        const uploadButton = document.getElementById('upload-btn');
        const completionMessage = document.getElementById('completion-message');
        const finalScoreElement = document.getElementById('final-score');
        const finalTimeElement = document.getElementById('final-time');

        // File upload elements
        const fileUploadModal = document.getElementById('file-upload');
        const closeUploadButton = document.getElementById('close-upload');
        const cancelUploadButton = document.getElementById('cancel-upload');
        const importTermsButton = document.getElementById('import-terms');
        const fileInput = document.getElementById('file-input');
        const fileDropArea = document.getElementById('file-drop-area');
        const pasteArea = document.getElementById('paste-area');
        const successMessage = document.getElementById('success-message');
        const errorMessage = document.getElementById('error-message');

        // Game state
        let activeCards = [];       // Cards currently in the grid
        let remainingCards = [];    // Cards still to be shown
        let learnedCards = [];      // Cards correctly identified
        let activeCardElement = null; // Currently flipped card container
        let gridSlots = [];         // Grid slots status (filled or empty)
        let inFinalStage = false;   // Whether we're in the final 8 cards
        let timerInterval = null;   // Timer interval reference
        let startTime = 0;          // Game start time
        let gameTime = 0;           // Total game time in seconds
        let availableCards = [];    // Cards available for shuffling (not yet learned)

        // Initialize game
        function initGame() {
            // Clear grid
            gridContainer.innerHTML = '';
            
            // Reset game state
            activeCards = [];
            learnedCards = [];
            activeCardElement = null;
            gridSlots = Array(8).fill(true); // All slots filled
            inFinalStage = false;
            
            // Create a deep copy of all flashcards for this game
            availableCards = [...allFlashcards];
            
            // Hide completion message
            completionMessage.classList.remove('show');
            
            // Shuffle all cards and split into active and remaining
            const shuffledCards = shuffleArray([...availableCards]);
            activeCards = shuffledCards.slice(0, 8);
            remainingCards = shuffledCards.slice(8);
            
            // Update display
            scoreElement.textContent = learnedCards.length;
            remainingElement.textContent = remainingCards.length;
            
            // Create initial grid with all slots filled
            for (let i = 0; i < 8; i++) {
                if (i < activeCards.length) {
                    const cardElement = createCardElement(activeCards[i], i);
                    gridContainer.appendChild(cardElement);
                } else {
                    // Create empty slots if needed
                    createEmptySlot(i);
                }
            }
            
            // Check if we're starting with fewer than 8 remaining cards
            if (remainingCards.length <= 8) {
                inFinalStage = true;
            }
            
            // Reset and start timer
            startTimer();
        }

        // Parse uploaded content to extract terms and definitions
        function parseTerms(content) {
            try {
                // Split by lines
                const lines = content.trim().split(/\r?\n/);
                
                // Array to hold the parsed terms
                const terms = [];
                
                // Process each line
                for (const line of lines) {
                    // Skip empty lines
                    if (!line.trim()) continue;
                    
                    // Find the first comma to split term and definition
                    const commaIndex = line.indexOf(',');
                    
                    // Skip invalid lines
                    if (commaIndex === -1) continue;
                    
                    // Extract term and definition
                    const term = line.substring(0, commaIndex).trim();
                    const definition = line.substring(commaIndex + 1).trim();
                    
                    // Skip if either term or definition is empty
                    if (!term || !definition) continue;
                    
                    // Add to terms array
                    terms.push({ term, definition });
                }
                
                // Return parsed terms
                return terms;
            } catch (error) {
                console.error("Error parsing terms:", error);
                return null;
            }
        }

        // Process file upload
        function handleFileUpload(file) {
            // Clear messages
            successMessage.style.display = 'none';
            errorMessage.style.display = 'none';
            
            // Only accept text or CSV files
            if (file.type !== 'text/plain' && file.type !== 'text/csv' && !file.name.endsWith('.csv')) {
                errorMessage.textContent = 'Please upload a TXT or CSV file.';
                errorMessage.style.display = 'block';
                return;
            }
            
            // Read the file
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                
                // Parse the terms
                const terms = parseTerms(content);
                
                // Check if parsing was successful and we have terms
                if (terms && terms.length > 0) {
                    // Set the new flashcards
                    allFlashcards = terms;
                    
                    // Show success message
                    successMessage.textContent = `Successfully imported ${terms.length} terms.`;
                    successMessage.style.display = 'block';
                    
                    // Close the modal after a short delay
                    setTimeout(() => {
                        closeUploadModal();
                        
                        // Reset and start a new game with the new terms
                        initGame();
                    }, 1500);
                } else {
                    // Show error message
                    errorMessage.textContent = 'No valid terms found in the file. Please check the format.';
                    errorMessage.style.display = 'block';
                }
            };
            reader.onerror = function() {
                errorMessage.textContent = 'Error reading the file.';
                errorMessage.style.display = 'block';
            };
            reader.readAsText(file);
        }

        // Import terms from paste area
        function importPastedTerms() {
            // Clear messages
            successMessage.style.display = 'none';
            errorMessage.style.display = 'none';
            
            // Get pasted content
            const content = pasteArea.value.trim();
            
            // Check if we have content
            if (!content) {
                errorMessage.textContent = 'Please paste some terms.';
                errorMessage.style.display = 'block';
                return;
            }
            
            // Parse the terms
            const terms = parseTerms(content);
            
            // Check if parsing was successful and we have terms
            if (terms && terms.length > 0) {
                // Set the new flashcards
                allFlashcards = terms;
                
                // Show success message
                successMessage.textContent = `Successfully imported ${terms.length} terms.`;
                successMessage.style.display = 'block';
                
                // Close the modal after a short delay
                setTimeout(() => {
                    closeUploadModal();
                    
                    // Reset and start a new game with the new terms
                    initGame();
                }, 1500);
            } else {
                // Show error message
                errorMessage.textContent = 'No valid terms found. Please check the format.';
                errorMessage.style.display = 'block';
            }
        }

        // Show the upload modal
        function showUploadModal() {
            // Reset the modal
            fileInput.value = '';
            pasteArea.value = '';
            successMessage.style.display = 'none';
            errorMessage.style.display = 'none';
            
            // Show the modal
            fileUploadModal.classList.add('show');
        }

        // Close the upload modal
        function closeUploadModal() {
            fileUploadModal.classList.remove('show');
        }

        // Shuffle current cards
        function shuffleDeck() {
            // Can't shuffle in final stage or if game is completed
            if (inFinalStage || learnedCards.length === allFlashcards.length) {
                return;
            }
            
            // Reset any active card
            if (activeCardElement) {
                const activeCard = activeCardElement.querySelector('.card');
                const activeFeedback = activeCardElement.querySelector('.feedback-btns');
                
                activeCard.classList.remove('flipped');
                activeFeedback.style.display = 'none';
                activeCardElement = null;
            }
            
            // Add shuffle animation to grid
            gridContainer.classList.add('shuffle-animation');
            
            // Wait for animation to complete
            setTimeout(() => {
                // Remove animation class
                gridContainer.classList.remove('shuffle-animation');
                
                // Build list of cards not yet learned
                const unlearned = availableCards.filter(card => 
                    !learnedCards.some(learned => learned.term === card.term)
                );
                
                // Shuffle the unlearned cards
                const shuffled = shuffleArray(unlearned);
                
                // Select new active cards
                const newActiveCards = shuffled.slice(0, 8);
                remainingCards = shuffled.slice(8);
                
                // Update active cards
                activeCards = newActiveCards;
                
                // Update display
                remainingElement.textContent = remainingCards.length;
                
                // Clear the grid
                gridContainer.innerHTML = '';
                
                // Rebuild the grid with new cards
                for (let i = 0; i < 8; i++) {
                    if (i < activeCards.length) {
                        const cardElement = createCardElement(activeCards[i], i);
                        gridContainer.appendChild(cardElement);
                    } else {
                        // Create empty slots if needed
                        createEmptySlot(i);
                    }
                }
                
                // Check if we're entering final stage
                if (remainingCards.length <= 8) {
                    inFinalStage = true;
                }
            }, 800);
        }

        // Start the timer
        function startTimer() {
            // Clear any existing timer
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            // Reset timer display
            gameTime = 0;
            timerElement.textContent = '00:00';
            
            // Record start time
            startTime = Date.now();
            
            // Start interval
            timerInterval = setInterval(updateTimer, 1000);
        }
        
        // Update the timer
        function updateTimer() {
            // Calculate elapsed time
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            gameTime = elapsedTime;
            
            // Format time as MM:SS
            const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
            const seconds = (elapsedTime % 60).toString().padStart(2, '0');
            
            // Update display
            timerElement.textContent = `${minutes}:${seconds}`;
        }
        
        // Stop the timer
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Format final time for display
            const minutes = Math.floor(gameTime / 60).toString().padStart(2, '0');
            const seconds = (gameTime % 60).toString().padStart(2, '0');
            finalTimeElement.textContent = `${minutes}:${seconds}`;
        }

        // Create a card element
        function createCardElement(card, position) {
            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container animate-in';
            cardContainer.dataset.position = position;
            
            const cardElement = document.createElement('div');
            cardElement.className = 'card';
            
            const cardFront = document.createElement('div');
            cardFront.className = 'card-face card-front';
            cardFront.textContent = card.definition;
            
            const cardBack = document.createElement('div');
            cardBack.className = 'card-face card-back';
            cardBack.textContent = card.term;
            
            const feedbackBtns = document.createElement('div');
            feedbackBtns.className = 'feedback-btns';
            
            const correctBtn = document.createElement('button');
            correctBtn.className = 'correct-btn';
            correctBtn.textContent = 'I knew it!';
            correctBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                handleCorrect(cardContainer, position);
            });
            
            const incorrectBtn = document.createElement('button');
            incorrectBtn.className = 'incorrect-btn';
            incorrectBtn.textContent = 'Still learning';
            incorrectBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                handleIncorrect(cardElement);
            });
            
            feedbackBtns.appendChild(correctBtn);
            feedbackBtns.appendChild(incorrectBtn);
            
            cardElement.appendChild(cardFront);
            cardElement.appendChild(cardBack);
            cardContainer.appendChild(cardElement);
            cardContainer.appendChild(feedbackBtns);
            
            // Add click event
            cardContainer.addEventListener('click', () => {
                flipCard(cardContainer, cardElement, feedbackBtns);
            });
            
            // Remove animation class after animation completes
            setTimeout(() => {
                cardContainer.classList.remove('animate-in');
            }, 500);
            
            return cardContainer;
        }

        // Create an empty slot
        function createEmptySlot(position) {
            const emptySlot = document.createElement('div');
            emptySlot.className = 'empty-slot';
            emptySlot.dataset.position = position;
            gridContainer.appendChild(emptySlot);
            gridSlots[position] = false;
        }

        // Flip a card
        function flipCard(cardContainer, cardElement, feedbackBtns) {
            // If another card is active, handle it first
            if (activeCardElement && activeCardElement !== cardContainer) {
                const activeCard = activeCardElement.querySelector('.card');
                const activeFeedback = activeCardElement.querySelector('.feedback-btns');
                
                activeCard.classList.remove('flipped');
                activeFeedback.style.display = 'none';
            }
            
            // Toggle current card
            if (cardElement.classList.contains('flipped')) {
                cardElement.classList.remove('flipped');
                feedbackBtns.style.display = 'none';
                activeCardElement = null;
            } else {
                cardElement.classList.add('flipped');
                feedbackBtns.style.display = 'flex';
                activeCardElement = cardContainer;
            }
        }

        // Handle correct answer
        function handleCorrect(cardContainer, position) {
            // Add to learned cards
            const cardIndex = parseInt(cardContainer.dataset.position);
            const learnedCard = activeCards[cardIndex];
            learnedCards.push(learnedCard);
            
            // Update score
            scoreElement.textContent = learnedCards.length;
            
            // Animate card out
            cardContainer.classList.add('animate-out');
            
            // Check if we're in final stage (8 or fewer cards remaining)
            if (inFinalStage || remainingCards.length <= 8) {
                inFinalStage = true;
                
                // After animation, remove the card and create empty slot
                setTimeout(() => {
                    // Remove from DOM
                    cardContainer.remove();
                    
                    // Mark slot as empty
                    gridSlots[cardIndex] = false;
                    
                    // Create empty slot
                    createEmptySlot(cardIndex);
                    
                    // Remove from active cards
                    activeCards[cardIndex] = null;
                    
                    // Check if all cards are gone
                    if (!activeCards.some(card => card !== null)) {
                        // Check if all available cards have been learned
                        if (learnedCards.length === allFlashcards.length) {
                            showCompletion();
                        }
                    }
                    
                    // Reset active card
                    activeCardElement = null;
                }, 500);
            } else {
                // After animation, replace with new card
                setTimeout(() => {
                    if (remainingCards.length > 0) {
                        // Get a new card
                        const newCard = remainingCards.shift();
                        
                        // Update remaining counter
                        remainingElement.textContent = remainingCards.length;
                        
                        // Replace in active cards array
                        activeCards[cardIndex] = newCard;
                        
                        // Create new card element
                        const newCardElement = createCardElement(newCard, cardIndex);
                        
                        // Replace in DOM
                        gridContainer.replaceChild(newCardElement, cardContainer);
                        
                        // Update final stage check
                        if (remainingCards.length <= 8) {
                            inFinalStage = true;
                        }
                    }
                    
                    // Reset active card
                    activeCardElement = null;
                }, 500);
            }
        }

        // Handle incorrect answer
        function handleIncorrect(cardElement) {
            // Flip card back
            cardElement.classList.remove('flipped');
            
            // Hide feedback buttons
            const feedbackBtns = activeCardElement.querySelector('.feedback-btns');
            feedbackBtns.style.display = 'none';
            
            // Reset active card
            activeCardElement = null;
        }

        // Show completion message
        function showCompletion() {
            // Stop the timer
            stopTimer();
            
            // Update final score
            finalScoreElement.textContent = learnedCards.length;
            
            // Show completion message
            completionMessage.classList.add('show');
        }

        // Shuffle array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Format time from seconds to MM:SS
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = (seconds % 60).toString().padStart(2, '0');
            return `${minutes}:${secs}`;
        }

        // Set up file drag & drop
        function setupFileDropArea() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                fileDropArea.addEventListener(eventName, preventDefaults, false);
            });
            
            ['dragenter', 'dragover'].forEach(eventName => {
                fileDropArea.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                fileDropArea.addEventListener(eventName, unhighlight, false);
            });
            
            fileDropArea.addEventListener('drop', handleDrop, false);
            
            // Click to select file
            fileDropArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            // Handle file input change
            fileInput.addEventListener('change', () => {
                if (fileInput.files.length > 0) {
                    handleFileUpload(fileInput.files[0]);
                }
            });
        }
        
        // Prevent default behaviors for drag & drop
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        // Highlight drop area when dragging over
        function highlight() {
            fileDropArea.style.backgroundColor = 'rgba(74, 111, 165, 0.1)';
            fileDropArea.style.borderColor = '#4a6fa5';
        }
        
        // Remove highlight when dragging out
        function unhighlight() {
            fileDropArea.style.backgroundColor = '';
            fileDropArea.style.borderColor = '';
        }
        
        // Handle file drop
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0) {
                handleFileUpload(files[0]);
            }
        }

        // Event listeners
        resetButton.addEventListener('click', initGame);
        shuffleButton.addEventListener('click', shuffleDeck);
        uploadButton.addEventListener('click', showUploadModal);
        closeUploadButton.addEventListener('click', closeUploadModal);
        cancelUploadButton.addEventListener('click', closeUploadModal);
        importTermsButton.addEventListener('click', importPastedTerms);

        // Set up file drop area
        setupFileDropArea();

        // Initialize the game
        initGame();
    </script>


</body></html>
